
# let foo : (forall a. a->a) -> ((forall a.a->a) -> (forall a. a->a)) = fun x -> x;;
val foo : (forall a. a -> a) -> (forall a. a -> a) -> forall a. a -> a = <fun>
# let bar :
  (((forall b. (b->b)->b->b) ->
   ((forall b. (b->b)->b->b) -> (forall b. (b->b)->b->b)) ->
    (forall b. (b->b)->b->b) -> (forall b. (b->b)->b->b))) = fun x -> x;;
Subsumption check failed: $1is not as polymorphic as forall b. (b -> b) -> b -> b

val id : forall a. a -> a = <fun>
# (id,id);;
- : (forall a. a -> a) * (forall a. a -> a) = (<fun>, <fun>)
# id::[];;
- : forall a. (a -> a) list = [<fun>]
# let ids = (id,id);;
val ids : (forall a. a -> a) * (forall a. a -> a) = (<fun>, <fun>)
# ids::[];;
- : forall a b. ((a -> a) * (b -> b)) list = [(<fun>, <fun>)]

TODO
  * EAnnot ではなく ELetAnnot, ELetRecAnnotを作るべきでは
  * let rec and
  * Pos



old LetRec
  --lift $ print e1
  e1_ty <- inferRho $ EFun f e1
  --lift $ print e1_ty
  e1_ty <- unifyFix e1_ty -- a->aの制限をつけてからquantify
  env_tys <- getEnvTypes
  env_tvs <- getMetaTyVars env_tys
  res_tvs <- getMetaTyVars [e1_ty]
  let forall_tvs = res_tvs \\ env_tvs
  e1_ty <- quantify forall_tvs e1_ty
  extendTyEnv f e1_ty (tcRho e2 exp_ty)
